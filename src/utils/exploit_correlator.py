"""Exploit correlation module for CVEScannerX."""

import json
import re
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
from ..utils.logger import get_logger
from ..utils.progress import ScanProgress

logger = get_logger(__name__)

class ExploitCorrelator:
    """Correlate CVEs with known exploits using searchsploit."""
    
    # Regular expressions for parsing exploit content
    CVE_PATTERN = re.compile(r'CVE-\d{4}-\d{4,}')
    VULNERABILITY_KEYWORDS = [
        'vulnerability', 'exploit', 'remote code execution', 'overflow',
        'injection', 'bypass', 'disclosure', 'XSS', 'SQLi', 'backdoor'
    ]
    
    def __init__(self):
        """Initialize exploit correlator."""
        self._verify_searchsploit()

    def _verify_searchsploit(self) -> None:
        """Verify that searchsploit is available."""
        try:
            subprocess.run(['searchsploit', '-h'], 
                         capture_output=True, 
                         check=True)
        except subprocess.CalledProcessError as e:
            logger.error("searchsploit command failed. Is exploitdb installed?")
            raise
        except FileNotFoundError:
            logger.error("searchsploit command not found. Please install exploitdb.")
            raise

    def search_exploits(self, cve_id: str) -> List[Dict]:
        """Search for exploits related to a CVE."""
        try:
            with ScanProgress(f"Searching exploits for {cve_id}") as progress:
                # Direct CVE search
                progress.update(description=f"Searching exact matches for {cve_id}...")
                result = subprocess.run(
                    ['searchsploit', '--cve', cve_id, '--json'],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                data = json.loads(result.stdout)
                exploits = data.get('RESULTS_EXPLOIT', [])
                
                # Format the initial results
                formatted_exploits = []
                seen_paths = set()
                
                for exploit in exploits:
                    path = exploit.get('Path', '')
                    if not path or path in seen_paths:
                        continue
                        
                    seen_paths.add(path)
                    formatted_exploit = {
                        'title': exploit.get('Title', ''),
                        'type': exploit.get('Type', ''),
                        'platform': exploit.get('Platform', ''),
                        'path': path,
                        'author': exploit.get('Author', ''),
                        'date': exploit.get('Date', ''),
                        'cves': [cve_id],
                        'match_type': 'direct',
                        'reliability': 'high'
                    }
                    
                    # Get additional details
                    content = self.get_exploit_details(path)
                    if content:
                        # Find additional CVEs
                        additional_cves = set(self.CVE_PATTERN.findall(content))
                        if cve_id in additional_cves:
                            additional_cves.remove(cve_id)
                        formatted_exploit['related_cves'] = list(additional_cves)
                        
                        # Extract potential indicators
                        formatted_exploit['indicators'] = self._extract_indicators(content)
                    
                    formatted_exploits.append(formatted_exploit)
                
                return formatted_exploits
                
        except subprocess.CalledProcessError as e:
            logger.error(f"Error searching exploits for {cve_id}: {e}")
            return []
        except json.JSONDecodeError as e:
            logger.error(f"Error parsing searchsploit output: {e}")
            return []
        except Exception as e:
            logger.error(f"Unexpected error during exploit search: {e}")
            return []

    def _extract_indicators(self, content: str) -> Dict[str, List[str]]:
        """Extract vulnerability indicators from exploit content."""
        indicators = {
            'vulnerability_types': [],
            'affected_components': [],
            'requirements': []
        }
        
        # Look for vulnerability keywords
        for keyword in self.VULNERABILITY_KEYWORDS:
            if keyword.lower() in content.lower():
                indicators['vulnerability_types'].append(keyword)
        
        # Extract requirements section if present
        if 'Requirements:' in content:
            req_section = content.split('Requirements:')[1].split('\n\n')[0]
            indicators['requirements'] = [
                r.strip() for r in req_section.split('\n')
                if r.strip() and not r.strip().startswith('#')
            ]
        
        return indicators

    def get_exploit_details(self, path: str) -> Optional[str]:
        """Get the content of an exploit file."""
        try:
            # First try direct path
            if Path(path).exists():
                with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                    return f.read()
            
            # Use searchsploit -x as fallback
            result = subprocess.run(
                ['searchsploit', '-x', path],
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout
        except (subprocess.CalledProcessError, FileNotFoundError, IOError) as e:
            logger.error(f"Error getting exploit details for {path}: {e}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error reading exploit: {e}")
            return None

    def update_database(self) -> Tuple[bool, str]:
        """Update the local exploit database."""
        try:
            with ScanProgress("Updating exploit database") as progress:
                result = subprocess.run(
                    ['searchsploit', '--update'],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # Parse the update output
                output = result.stdout.strip()
                if "[i] No updates needed" in output:
                    return True, "Database is up to date"
                elif "[+] Exploit Database updated" in output:
                    return True, "Database successfully updated"
                else:
                    return True, output
                    
        except subprocess.CalledProcessError as e:
            error_msg = f"Error updating exploit database: {e}"
            logger.error(error_msg)
            return False, error_msg
        except Exception as e:
            error_msg = f"Unexpected error during database update: {e}"
            logger.error(error_msg)
            return False, error_msg
